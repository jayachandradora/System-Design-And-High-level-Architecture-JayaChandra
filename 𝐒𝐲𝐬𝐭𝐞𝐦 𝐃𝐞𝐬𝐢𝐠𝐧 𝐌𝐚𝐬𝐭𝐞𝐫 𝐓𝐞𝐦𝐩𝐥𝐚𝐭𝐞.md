![image](https://github.com/user-attachments/assets/77dbe8f2-c285-4d68-857a-a40401b70811)

If you're just getting started with system design,
here are some concepts you must learn:


1 Core Architecture:

â€¢ Monolith
â†³ An all-in-one application structure that is run as a single service.

â€¢ Modular Monolith
â†³ An app structured as independent, loosely coupled modules that can be deployed together.

â€¢ Microservices
â†³ Loosely coupled, independently deployable services.

â€¢ Serverless
â†³ Run code without provisioning servers.

â€¢ Event-Driven Architecture
â†³ Services emit and react to events.

â€”â€”

2 Design Patterns:

â€¢ Idempotency
â†³ Safe retries of the same operation without side effects.

â€¢ Circuit Breaker Pattern
â†³ Prevents cascading failures in microservice calls.

â€¢ API Gateway
â†³ API entry point that does request routing.

â€¢ Service Registry
â†³ Dynamically tracks instances in a microservices architecture.

â€¢ Service Mesh
â†³ An infrastructure layer to manage service interaction in a microservices architecture.

â€¢ Message Queue
â†³ A method to achieve asynchronous communication between services.

â€¢ Orchestration
â†³ A central coordinator controls the interaction between services.

â€¢ Choreography
â†³ Decentralized interaction between services via events.

â€”â€”

3 Scalability & Reliability:

â€¢ Replication
â†³ Maintaining many copies of data for availability.

â€¢ Failover
â†³ Switching to a backup server on failure.

â€¢ Autoscaling
â†³ Automatically adjust resources based on demand.

â€¢ Rate Limiting
â†³ Restricting the number of requests against an API in a specific timeframe.

â€¢ Sharding
â†³ Split the database into smaller pieces for parallelism and scale.

â€¢ Load Balancer
â†³ Distributes traffic uniformly among the servers.

â€¢ Load Shedding
â†³ Drop low-priority traffic to maintain system health.

â€¢ Containerization
â†³ Encapsulating the app and its dependencies for portability across different environments

â€¢ Kubernetes
â†³ Automates the deployment and scaling of containers.

â€”â€”

4 Data Access:

â€¢ CDN
â†³ A geographically distributed server delivering content based on user location.

â€¢ Database Indexing
â†³ Speed up database queries using a data structure.

â€¢ SQL vs NoSQL
â†³ Relational vs non-relational database.

â€¢ ACID vs BASE
â†³ Strong consistency vs eventual consistency.

â€¢ Cache
â†³ A component that stores frequently accessed items for fast access.

â€¢ Data Lake
â†³ Raw data storage for scale and flexibility.

â€¢ OLTP vs OLAP
â†³ Transactional vs analytical processing.

â€¢ CAP Theorem
â†³ Consistency, Availability, Partition Tolerance - choose 2.

â€¢ Data Warehouse
â†³ Structured storage for reports and analytics.

â€¢ Quorum
â†³ Agreement mechanism in distributed systems.

<img width="566" alt="image" src="https://github.com/user-attachments/assets/32e8483a-d4a2-4643-93af-df7f8a8cb2a7"># ğ’ğ²ğ¬ğ­ğğ¦ ğƒğğ¬ğ¢ğ ğ§ ğŒğšğ¬ğ­ğğ« ğ“ğğ¦ğ©ğ¥ğšğ­ğ

![image](https://github.com/user-attachments/assets/e04169e9-cbc1-45ae-8af8-2c926d3962af)


![image](https://github.com/user-attachments/assets/9c64ae21-64da-44a7-81c3-83cc65711eb9)

The System Design Master Template is a comprehensive resource that covers the key components of scalable and robust systems.

### These components include:

- ğƒğ¨ğ¦ğšğ¢ğ§ ğğšğ¦ğ ğ’ğ²ğ¬ğ­ğğ¦ (ğƒğğ’): It is responsible for translating domain names into IP addresses, which are used to locate and access web servers.

- ğ‹ğ¨ğšğ ğğšğ¥ğšğ§ğœğğ«: This ensures that no single server is overloaded and that users can access the system even if one server fails.

- ğ€ğğˆ ğ†ğšğ­ğğ°ğšğ²: It acts as a buffer between the client and the backend servers, providing a single point of control and visibility.

- ğ‚ğ¨ğ§ğ­ğğ§ğ­ ğƒğğ¥ğ¢ğ¯ğğ«ğ² ğğğ­ğ°ğ¨ğ«ğ¤ (ğ‚ğƒğ): It delivers content to users from the server that is closest to them, reducing latency and improving performance.

- ğ…ğ¨ğ«ğ°ğšğ«ğ ğğ«ğ¨ğ±ğ² ğ¯ğ¬. ğ‘ğğ¯ğğ«ğ¬ğ ğğ«ğ¨ğ±ğ²: Both types of proxies can be used to improve security and performance.

- ğ‚ğšğœğ¡ğ¢ğ§ğ : Caching is the process of storing frequently accessed data in memory for faster retrieval. This can improve the performance of a system significantly.

- ğƒğšğ­ğš ğğšğ«ğ­ğ¢ğ­ğ¢ğ¨ğ§ğ¢ğ§ğ : This can improve the efficiency of data storage and retrieval.

- ğ’ğ¡ğšğ«ğğ¢ğ§ğ : This can improve the performance and scalability of a database.

- ğƒğšğ­ğšğ›ğšğ¬ğ ğ‘ğğ©ğ¥ğ¢ğœğšğ­ğ¢ğ¨ğ§: This can improve data availability and fault tolerance.

- ğƒğ¢ğ¬ğ­ğ«ğ¢ğ›ğ®ğ­ğğ ğŒğğ¬ğ¬ğšğ ğ¢ğ§ğ  ğ’ğ²ğ¬ğ­ğğ¦ğ¬: This is essential for coordinating the activities of different components and ensuring that the system functions as a whole.

- ğƒğ¢ğ¬ğ­ğ«ğ¢ğ›ğ®ğ­ğğ ğ…ğ¢ğ¥ğ ğ’ğ²ğ¬ğ­ğğ¦ğ¬: This is essential for managing large volumes of data across multiple servers.

- ğğ¨ğ­ğ¢ğŸğ¢ğœğšğ­ğ¢ğ¨ğ§ ğ’ğ²ğ¬ğ­ğğ¦: This can be done through email, SMS, push notifications, or other means.

- ğ…ğ®ğ¥ğ¥-ğ­ğğ±ğ­ ğ’ğğšğ«ğœğ¡: Full-text search allows users to find information quickly and accurately by searching across the entire text of a document or database.

- ğƒğšğ­ğš ğ–ğšğ«ğğ¡ğ¨ğ®ğ¬ğ: It is typically used to support business intelligence and decision-making.

- ğƒğ¢ğ¬ğ­ğ«ğ¢ğ›ğ®ğ­ğğ ğ‚ğ¨ğ¨ğ«ğğ¢ğ§ğšğ­ğ¢ğ¨ğ§ ğ’ğğ«ğ¯ğ¢ğœğğ¬: This is essential for ensuring that the system functions correctly and reliably.

By understanding the key components of system design, you can build scalable and robust systems that can meet the needs of your users.


![Uploading image.pngâ€¦]()

Batch Processing vs Real-time Streaming.

Two approaches for your data pipelines, one goal: turning raw data into real insights.

ğ—•ğ—®ğ˜ğ—°ğ—µ ğ—½ğ—¿ğ—¼ğ—°ğ—²ğ˜€ğ˜€ğ—¶ğ—»ğ—´  operates on large volumes of data collected over a defined window. Hours, days, or weeks. Ideal when latency isnâ€™t critical and efficiency is the priority.

ğ—¥ğ—²ğ—®ğ—¹-ğ˜ğ—¶ğ—ºğ—² ğ˜€ğ˜ğ—¿ğ—²ğ—®ğ—ºğ—¶ğ—»ğ—´, on the other hand, minimizes the delay between event generation and system response. Instead of waiting for a full dataset, you process each event as it arrives.

ğ—§ğ—µğ—² ğ—¸ğ—²ğ˜† ğ˜ğ—¿ğ—®ğ—±ğ—²ğ—¼ğ—³ğ—³ğ˜€?

â€¢ Batch = Simpler, slower, cheaper.
â€¢ Streaming = Faster, more complex, higher ops overhead.

Most mature systems combine both.
Batch for deep, historical analysis; streaming for instant reactions.

